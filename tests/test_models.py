import pytest
from langchain_core.messages import AIMessage, HumanMessage

from core.models import (
    ChatMessage,
    Citation,
    Embedding,
    Document,
    User,
)
from .conftest import gaussian


@pytest.mark.django_db
def test_chat_to_langchain(chat):
    ChatMessage.objects.create(
        chat=chat, content="tell me a story", type=ChatMessage.TYPES.HUMAN
    )
    ChatMessage.objects.create(
        chat=chat, content="the cat sat on the mat", type=ChatMessage.TYPES.AI
    )

    assert chat.to_langchain() == [
        HumanMessage(content="tell me a story"),
        AIMessage(content="the cat sat on the mat"),
    ]


@pytest.mark.django_db
def test_chat_from_langchain(chat):
    initial_count = chat.chatmessage_set.count()

    ChatMessage.from_langchain(chat, HumanMessage(content="tell me a story"))
    ChatMessage.from_langchain(chat, AIMessage(content="the cat sat on the mat"))

    chat.refresh_from_db()

    final_count = chat.chatmessage_set.count()

    assert final_count == initial_count + 2


@pytest.mark.django_db
def test_chat_annotated_content(chat_message):
    Citation.objects.create(
        chat_message=chat_message,
        text_in_answer="the cat",
        text_in_source="cats are nice",
        reference="www.catfacts.com",
        index=1,
    )

    content = chat_message.annotated_content()
    assert (
        content
        == 'the cat[^1] sat on the mat\n\n[^1]: "cats are nice" [source](www.catfacts.com)'
    )


@pytest.mark.django_db
def test_chat_annotated_content_no_citations(chat_message):
    assert chat_message.annotated_content() == "the cat sat on the mat"


@pytest.mark.django_db
def test_embedding_search_by_vector(user_embedded_document):
    # Given a set of embeddings which are generated by a gaussian centered around their index number
    # When I query against a vector centered around index==3
    embedding = [gaussian(i, 3) for i in range(3072)]
    actual_embeddings = Embedding.search_by_vector(
        user_embedded_document.user_id, embedding
    )

    # I Expect the first result to have index 3
    assert actual_embeddings[0].metadata["index"] == 3
    # And the next results to have an index equal to the nearest numbers
    assert actual_embeddings[1].metadata["index"] in (2, 4)
    assert actual_embeddings[2].metadata["index"] in (2, 4)


@pytest.mark.django_db
def test_document_status_processing(user_document):
    assert user_document.status == "PROCESSING"


@pytest.mark.django_db
def test_document_status_complete(user_embedded_document):
    assert user_embedded_document.status == "COMPLETE"


@pytest.mark.django_db
def test_document_status_error(user_document):
    user_document.processing_error = "some error"
    user_document.save()
    assert user_document.status == "ERROR"


@pytest.mark.django_db
def test_document_delete_by_name(user_document):
    assert Document.delete_by_name(user_document.user, user_document.file.name)


@pytest.mark.django_db
def test_document_generate_elements(user_document, fake_embeddings):
    assert user_document.status == "PROCESSING"
    assert user_document.processing_error is None
    assert user_document.embedding_set.count() == 0
    user_document.generate_elements()

    assert user_document.status == "COMPLETE"
    assert user_document.processing_error is None
    assert user_document.embedding_set.count() == 1


@pytest.mark.django_db
def test_model_get_history(user_with_many_chat_messages):
    # Given a user with 10 chats with a 0 to 10 messages each
    # When I call get_history(limit=5)
    # I Expect 5 chats, all with more than 1 message returned
    chats = user_with_many_chat_messages.get_history(limit=5)
    assert len(chats) == 5
    assert all(chat.chatmessage_set.count() > 1 for chat in chats)


@pytest.mark.django_db
def test_create_superuser():
    user = User.objects.create_superuser("me@example.com", "password")
    assert user.email == "me@example.com"
    user.delete()
